## 2022.12.01
12월의 첫 날이 왔다.  
오늘은 야심차게 DB 연결도 하고 이것저것 바꾸면서 시도해보려고 했는데, 결론적으론 별로 못했다.  
우선 공부하느라 밀린 업무도 조금 하고  
DB를 강의에서 사용한 h2를 쓰려고 했는데, 기존에 연결을 했어서 경로를 찾지 못해 시간이 좀 걸렸다.  
겨우 DB 세팅을 하고, table 생성하는 것 까지 마쳤다.  
이제 내일은 진짜 시작할 수 있을거다!  
그리고 최근에 코딩 공부 스터디를 만들어서 자바 코테 문제를 풀고있다.  
아직 자바가 낯설어서 자바의 구조와 익숙해지는 시간이 필요해보인다.  
12월의 나 화이팅!!  

## 2022.12.02
음.. 우선은 DB 연결은 했다.  
필드 값에 맞춰서 Entity를 완성하고, JpaRepository 인터페이스를 통해 SpringDateJpaMemberRepository도 만들었다.  
그런데, 홈 화면에서 입력받은 값이 자동으로 DB에 저장된다고 생각했는데, 그것까지는 작동이 안 된다..  
그리고 아직 dto는 사용하지 않았는데, 이 때문인지 아니면 다른 설정을 놓친건지 모르겠다.  
entity, repository, controller, dto 이렇게 각각의 파일들은 어떻게든 찾아서 만들 수 있을 것 같은데  
이들을 연결시키고, Service에서 자유자재로 활용하는 부분이 제일 어렵다.  
이제 이걸 집중해서 공부해야지 힘내자!  

## 2022.12.05
Controller를 통합하고(MemberController만 사용) 다른 Controller에 있는 코드들은 requestDto에 반영했다.  
requestDto에는 name 변수 하나만 넣어서 create를 할 때 입력하는 이름을 받도록 만들었다.  
그리고 Service를 변경사항에 맞춰서 수정하고있었다.  
그런데 문제는 id가 순서대로 자동으로 생성되어서 기존의 create 코드에서도 Entity(id, name)을 그대로 사용한다는 걸 발견했다.  
즉, Dto를 만들 이유가 없다. 여기서부터 공부한 내용들이 꼬이기 시작했고 코드는 엉망진창이 되었다.  
굳이 dto를 사용하는 방법으로 계속 이어나갈지, 그래도 직접 치면서 공부한 것에 만족하고 끝낼지 고민이다.  
머리가 복잡해져서 지금까지 배운 내용을 핵심만 뽑아서 정리했다.  
파일들을 연결하는 과정이 완전히 이해되지 않아서 각각의 Input, Output을 명시하고, 이름을 직관적으로 적었다.  
그 과정에서 service를 찬찬히 하나씩 살펴봤는데, 정리하기가 참 어려웠다.  
내가 참고하던 코드는 두 팀원 분들과 spring 공부하면서 작성한 코드이다.  
그런데 두 분의 코드 스타일이 완전 다르다. 한 분은 변수들을 연결하는 방식, 다른 분은 entity에 작성한 함수를 사용하는 방식이다.  
정답은 없지만 일단은 한가지 방법으로 정해야 코딩할 수 있을텐데 고민이다.  

## 2022.12.06
배운 걸 토대로 업무를 시작했다.  
entity, repository, dto 등은 작성해뒀는데, 이제야 조금씩 뭐가 뭔지 알겠어서 코드들을 점검했다.  
보다보니 또 배울 것이 생겼다.  
entity에서 생성자를 만드는데, 한 필드가 parameter 값이 없어서 다르게 처리해야 하는지 보는 중이다. (ex) debitBalance: 0L;)  
그리고 repository에서 다른 테이블의 key 값은 self로 left join fetch를 해야하는 걸 배웠다.  
그 구문이 없으면, 다른 테이블과의 연결에 대한 정보들을 사용할 수 없게 된다.  
내일은 controller와 service를 볼 예정이다.  
이제 swagger가 뭐고, 비즈니스 로직을 어떻게 짤 지에 대해 많이 배울 것으로 보인다.  
이번 업무의 목표는 이번주 금요일까지 차기이월 계산 로직을 완성해야 한다. 화이팅!!!!!  

## 2022.12.07
요즘은 진짜 바쁘다..  
업무에서 entity, repository, dto는 미리 작성해둬서 오래 안 걸릴 거라 생각했는데, crud 연습을 한 후에 보니 부족한 부분이 너무 많아서 다시 다 수정하고 있다.  
아무래도 이번주까지 끝내기는 어려울 것 같은데 그래도 일단 평일에 최대한 물어보고 주말에 머리를 쥐어짜면 될 수도 있지 않을까 싶기도 하다.  
오늘은 repository 부분을 중점적으로 수정했다.  
join은 사용하지 않지만 복잡한 쿼리문을 @Query를 사용해서 작성해 뒀는데, JPAQueryFactory로 바꿔야 하나 고민 중이다. JPA 기준에서 복잡하지 않는 범위가 어떻게 되는지 궁금하다.  
그리고 DB에 dummy data 들이 없어서 만드려고 sql을 열심히 했는데 자동 생성되는 id 같은 column 때문인지 자꾸 에러가 난다.  
그래서 아예 spring을 사용해서 데이터를 넣는 방법으로 해결하고자 한다.  
그런데 아직 그 방법도 모르고, controller의 swagger 기능이 필요해 보이는데 이 부분은 공부가 더 필요하다.  
내일 회사 오면 바로 물어봐야겠다.  
오늘의 나, 수고했다 내일도 화이팅!  

## 2022.12.09
엄청 찾아보고, 배우고, 해보면서 정말 많은 것들을 알게 되었다.
너무 많고 흩어진 정보들이라서 정리를 어떻게 할지 고민이다.
그래도 가장 인상깊었던 배움은 화면단으로 보이는 변수만 가져오는 것은 아니라는 거다.
그러니까, 한 entity의 정보(id)만 받으면 그 이후에는 repository와 service에서 찾으면서 연결하면 된다.
덕분에 여태까지 한 개발이 거의 뒤엎어졌다..
아예 requestDto의 변수도 확 줄고, 구조 자체도 바뀌고, 쿼리문도 훨씬 단순하게 만들 수 있다.
repository와 dto는 얼추 만들었고, 이제 조금 알 것 같아서 괜찮은데, service가 문제다..
service에서 서로 다른 곳에서 온 변수들을 연결해주어야 하는데, 아직 모르는 것이 많아서 쉽지 않다.
원래 목표는 오늘까지 service(+controller) 완성이었는데, 목표 업무의 절반 정도만 개발한 상태이다.
그래서 주말에 service를 최대한 만들고 월요일에 약간의 수정만 받으려고 한다.
간만에 주말 출근이다 화이팅ㅎㅎ

## 2022.12.10
오늘은 코드를 좀 짰다!
하루 자고 맑은 정신으로 코드를 다시 보니, 어제에는 안 보이던 것들이 보였다.
service를 중심으로 repository와 dto를 연결한다는 말이 무슨 말인지 알 것도 같다.
덕분에 우선 어제 목표한 만큼의 코드는 대략 완성했다.
하지만 처음 목표에 비하면 다소 작성하지 못한 기능들이 많다.
가능하면 내일 와서 마저 코드를 짜보려고 한다.
수고했다!^^

## 2022.12.12
주말동안 열심히 짠 코드를 보여주고 리뷰를 받았다.  
간단하게만 수정한 뒤에 실행시켰고, 다행이도 잘 돌아갔다.  
그리고 나서는 값이 맞는지 확인하기 위해 swagger로 돌려봤다.  
내가 짠 부분이 response에는 포함되어 있지 않고 save만 해서, debug를 해봤다.  
에러없이 잘 돌아가기는 하는데 값을 어떻게 보는지 못찾고있다.  
우선은 QueryDSL 관해서 git에 정리하면서 가볍게 마무리하려고 한다.  

## 2022.12.13
previous, current 기능 모두 잘 돌아가고 값도 원하는 대로 나와서 점검은 얼추 되었다.  
이제 current의 type을 dto에서 entity로 바꿔야 하는데, return new로 하려니까 error가 뜬다.  
좀 더 고민해봐야겠다.  

## 2022.12.14
dto의 타입을 바꾸려고 했는데, 우선 current와 previous를 더한 다음에 바꾸려고 한다.  
더하는 작업을 join을 써야하나 했는데, current는 현재 dto 방식이기도 하고 db에 이 값 자체를 저장할 생각은 아니라서 다른 방법을 생각해봤다.  
join보다는 좀 비효율적이긴 하겠지만 loop를 돌려서 id가 맞는 값끼리 더하려고 한다.  
그래도 시간 복잡도와 서비스의 부담을 줄이기 위해서 id를 순서대로 정렬하고(long 타입) 앞에서부터 둘을 비교하면서 채워넣으려고 한다.  
이렇게 보니 코딩테스트 연습하던 때가 생각난다. JAVA 스터디를 더 열심히 해둘걸 그랬다ㅎㅎ  
그래도 이제 길이 보여서 마음이 한결 편하다  
이번주 안에 끝내고 싶은데 가능할지는 모르겠다. 화이팅!  

## 2022.12.15
회계 관련해서 설계 방법을 논의하다보니 오후가 반 쯤 남아있었다.  
자바를 살펴보니 for 문도 다양한 종류가 있었다.  
for each라는 것도 있어서 어떤 for 문을 써야할까 고민했는데, for each는 for 문 안에서 변수를 수정할 수 없어서 맞지 않았다.  
결국 돌아와서 for 문을 쓰기로 결정하고 코드를 짜는데 생각보다 너무 어려웠다.  
python으로 하면 진작 했을텐데 문법을 몰라서 찾느라 시간이 오래 걸린다.  
하고 싶은 건 list<Entity> 형식으로 있는 자료에서 row와 column을 찾으면서 하나씩 돌리는 건데  
Entity[i], Entity.i 이런 식으로 변형을 하다보니 Entity.get(row).getColumnName() 코드를 찾아냈다!  
그리고 이제 해야하는건 List<dto> 형식에서도 같은 작업을 해야하는건데 왜인지 Entity와 같은 문법을 적용했는데 안 된다.. stream 이란걸 써야하는건가?  
이제 이 방법을 찾고 코드를 짜다보면 내일도 다 갈 것 같다.  
  
## 2022.12.16
List<dto> 형식에서 검색이 안 되던 이유는 @Getter, @Setter, @NoArgsConstructor, @AllArgsConstructor 등의 어노테이션을 사용하지 않아서였다.  
사실 아직 어노테이션들의 정확한 기능을 알지는 못했는데, 이번에 코드를 작성하면서 언제 어떤 어노테이션이 필요한지를 알게되었다.  
조금 더 익숙해지면 어노테이션들에 대해서도 공부하고 정리해야겠다.  
그리고 for문을 사용해서 값을 계산하는 코드를 작성하면서 List<entity/dto>에서 column(field) 값만 뽑아서 해결하려고 했는데, java에서는 for문을 또 따로 사용해야 column의 값들을 구할 수 있었다. 시간복잡도를 낮추기 위해 찾아봤던 터라, 다른 방법을 적용해서 해결했다.  
이럴때는 행, 렬 모두 한번에 불러올 수 있는 R이 그립기도 하다..  
어쨌든 다양한 방법을 생각하다가 시간복잡도가 가장 낮은 방식을 선택하고 코드를 짰다.  
코딩 테스트 문제같은 형식이라 익숙하고, java와도 조금씩 친해지다보니 다른 코드들에 비해 훨씬 빠르게 짰다.  
이제 계산 기능을 본 service에 적용하는 일만 남았다. 이제 진짜 거의 다 했다!!  
+) 고민했던 계산 방법들은 어떻게 정리할지 고민중이다.  

## 2022.12.21
개발하고자 하는 기능은 한 List<entity>의 previous 값과 current 값을 더해서 저장하는 거였다.  
여기서 고민되었던 부분은, 둘의 특정 id가 같으면 두 값을 더해서 저장해야했다.  
sql에서 union, join을 사용하면 편했겠지만 이미 entity 형식으로 구현했기 때문에 다른 방법을 찾아야 했다.  
생각한 방법은 3가지였다.  
  1. previous와 current의 id를 순서대로 정렬한 상태에서 id를 하나씩 비교하면서 작은 값을 우선 저장하고 그 다음 id로 넘어가서 다시 비교를 반복하는 방법  
  2. previous를 넣어두고 current를 돌리면서 contain하고 있으면 더하고, 없다면 새로 row를 추가하는 방법  
  3. previous와 current id의 set을 만들어두고 이를 차례대로 돌리면서 생성하고 값을 더하는 방법  
  
여기에서 가장 중요하게 생각한 부분은 시간 복잡도다. 이 list의 길이가 약 3000개 정도 되어서 단순히 이중 for문을 쓰기에는 부담됐다.  
그래서 시간 복잡도가 p.size + c.size인 1번 방법을 선택했다.  
그런데 로직이 다소 직관적이지 않고 경우에 따라 id를 넘기는 방법이 다르기 때문에 if문에 따른 비슷한 코드를 3번 작성했다. 코드가 맘에 들진 않았지만 우선 얼추 짰고 데이터를 넣어서 돌려보는 일만 남아있었다.  
그러다가 다른 방법들을 더 살펴보던 중에 hashmap을 알게 되었다.  
원래 2, 3번 방법을 채택하지 않은 이유는 id를 저장한 array에서 특정 id를 contain하고 있는지를 알아보기 위해서 for과 같은 시간복잡도가 필요하기 때문이었다.  
그런데 hashmap을 사용하게 되면, contain을 사용해도 O(1) 정도여서 1번 방법과 시간 복잡도가 거의 비슷해졌다.  
그래서 1번 방법으로 짠 코드는 두고 hashmap을 이용해서 2번 방법으로 코드를 다시 짜고 있다.  
1번 코드를 짜면서 로직이 조금 익숙해진 덕분에 시간은 오래 걸리지 않을 것 같다.  
코드가 얼마나 더 깔끔해질지 기대된다ㅎㅎ 열심히 해서 내일까지 끝내고 싶다.  
무사히 돌아가길.. 내일의 나 화이팅!!  

## 2022.12.22
오늘은 많이 못했다. hashmap이 아직 헷갈리기도 하고, 경우에 따라 조금씩 결과값을 다르게 내야 해서 entity 형태의 temp들을 만들어서 저장하는데, 이러면 전의 1번 방법과 크게 다르지 않은 것 같다  
오히려 hashmap의 key가 id인데, 이 id를 돌리려면 새 arraylist를 만들어야하나 싶다.  
그래도 오늘의 수확은 for 대신 foreach를 사용할 수 있다는 점이다.  
1번 방법은 값 자체를 변경해서 저장해야했기 때문에 foreach를 사용할 수 없었지만, 이번에는 id list를 돌리고 결과 값을 따로 계산하기 때문에 foreach 사용이 가능하다.  
그리고 또 고민중인 것은 이제 값을 계산해서 List<Entity> 형태로 쌓으면 이를 db를 저장해야하는데, saveAndFlush에 대해 잘 모르겠다. repository로 저장하는 것 같은데 변수가 List<Entity> 형식이어서 맞지 않는 것 같기도 하다.  
거의 다 끝났다고 생각할 때마다 다시 막힌다.. 내일까지 할 수 있을까 힘내보자  

## 2022.12.23
드!디!어! 기능 개발을 완료했다!!!!!!!!!  
우선 우려했던 대로 1번 방법과 코드의 길이는 별 차이가 없기는 하지만 그래도 방법이 직관적이라 2번 방법을 그대로 사용했다. 아쉽게도 한번에 column 값을 넣는 방법은 없었다.  
그리고 hashmap에 foreach를 돌리기 위해 새 arraylist를 파야하나 했는데, 아예 변수를 Entity 형식의 데이터로 바로 넣고 그 안에서 원하는 값을 뽑아내면서 해결했다.  
saveAndFlush에 대해서는 어제 생각한대로 List 형식이기 때문에 saveAllAndFlush를 사용해야했다. 여기에 Hashmap.values()가 set 형식으로 나오는데, 이를 List 형태로 바꾸어서 저장했다. 아직 자세히는 모르겠지만 set보다는 list 형태로 저장하는 편이 더 적절하다고 한다.  
이렇게 기능을 다 개발했고 db에 데이터 넣어서 돌려봐도 아주 잘 돌아간다^^  
그리고 부가적으로 개발한 기능을 다시 취소하는 기능도 개발했다.  
이미 작성한 코드들이 있어서 많이 참고한 덕분에 시간은 별로 안 걸렸다.  
이번주 금요일에 딱 이렇게 마무리가 되니까 기분이 좋고 편안한 주말을 보낼 수 있을 것 같다^^  
p.s.) 기존의 1번 방법은 private repository에 저장해뒀다.  

## 2022.12.26
오늘은 예외처리 코드를 짰다.  
previous가 애초에 존재하지 않는 경우, 존재하는데 db에 반영되지 않은 경우 등이 발생할 때, Error 메세지를 보내도록 작성했다.  
원래는 오늘 바로 MR를 날리려고 했는데 예외처리 코드를 작성하면서 발생한 작은 오류가 있어서 오늘은 못했다.  
지금은 도저히 보이지가 않아서 내일 다시 생각하고 수정해서 마치려고 한다.  
내일 코드리뷰까지 받아서 merge 하면, 이제 기간비용현황을 조회하는 화면을 개발할 예정이다.  
지금까지는 좀 더 비즈니스 로직을 짰다면, 기간비용현황은 CRUD 측면이라 좀 다를 것 같다.(아마 더 쉬울 듯) 기대된다!  

## 2022.12.27
오늘 merge를 날리려고 했지만, 추가적으로 고려해야 할 예외사항이 있어서 추가하면서 시간을 보냈다.  
우선 어제의 오류는 request 쿼리문에서 오타가 있어서 생긴 거였다. 유료버전의 intelliJ를 설치하면 틀린 부분이 하이라이트 처리된다고 하던데 유료버전 설치를 다시 시도해볼까 고민된다.  
그리고 오늘은 이월할 기수가 회사의 첫 기수에 해당하는 경우에 대해 예외처리 코드를 작성했다.  
기존에는 previous + current로 했지만, 첫 기수라면 previous가 없을 테니 구분이 필요했다. 그리고 해당 기수가 첫 기수인지를 판별하기 위해 회계기수에서 repository를 추가로 작성해서 산출했다. 처음에는 min 을 사용할까 하는 생각이 먼저 들었지만, 그러면 arraylist를 뽑거나 for 문이 필요할 것 같아서 기수 번호를 order by해서 0번째 row를 선택했다.  
이제 Merge Request만 보내면 되는데, IntelliJ로 + GitLab에 MR하는 것은 처음이라 (혹시 모르니) 내일 물어보면서 안전하게 MR을 날리려고 한다.  
그 뒤에는 어제 계획대로 기간비용현황을 어떻게 구현할지 구상하고 코드 작성에 들어갈 생각이다.   

## 2022.12.28
오늘 드디어 머지까지 완료했다!!!!!!!!!!!  
어제 혼자 푸시하지 않은 건 탁월한 선택이었다. 구글링해서 찾은 intelliJ의 task를 활용해서 머지하는 방법을 시도하려고 했는데, 지금 하는 프로젝트에서는 해당 방법을 사용하지 않았다.  
그리고 코드리뷰를 기다리는 동안 기간비용현황에 대해 구상을 좀 했다.  
아직 ui가 나오지 않았기 때문에, 참고자료를 보면서 공통적으로 필요할만할 request, response, 기능들을 선별했다.  
request dto도 만들고, 남은 일수, 잔액 등을 보여줄 query도 만들고 있다. 처음에는 간단하게 @Query 어노테이션을 사용해서 불러오고 service 단에서 처리하려고 했는데 어차피 다른 entity와 join하고 column도 추가 생성해야할 것으로 보여서 아예 QueryDSL로 작성하려고 한다.  
어려운 이월 로직을 끝내고 새로 시작하니 마음도 가볍고 재밌다ㅎㅎ 이번 것도 잘 해보자!  

## 2022.12.29
다시 생각해보니, 각 기간비용마다 개별적인 현황을 보여줘야하기 때문에 response 창은 두 개로 분리되어야 한다.  
하나는 기간비용 전체 list, 그리고 기간비용을 선택했을 때 연월별 현황 table이 필요하다.  
그래서 어제 생각했던 내용에서 다소 수정하면서 service가 어떻게 나와야할 지 고민했다.  
front 화면이 없으니, 막막하다.. 차라리 참고자료의 화면을 그대로 만든다고 생각하고 개발해야겠다.  
