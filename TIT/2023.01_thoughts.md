## 2023.01.02
새해가 밝았다. 별로 체감이 되지는 않다.  
오늘은 (조건에 맞는) 기간비용 리스트를 모두 read하는 기능을 구현했다.  
request 조건으로 검색하기 위해서는 전표 entity와 join이 필요하다. join 후에 where 조건만 걸으면 돼서 쿼리 자체는 간단하지만, 전표의 양이 굉장히 많아서 시스템에 부하가 걸릴지 않을까 걱정되었다. 팀원과 상의하고 우선 이부분은 고려하지 않고 구현하기로 했다.  
그리고 response에 계정과목 이름까지 나타내기 위해서 총 3번의 join이 필요했다. JPAQueryFactory를 사용해서 구현했는데, 연속으로 join을 걸어도 작동하는지는 확신이 서지 않는다.  
그래서 일단은 service, controller까지 생성하고 내일 swagger에 등록하고 돌려보면서 확인하려고 한다.  
여전히 시스템 과부하가 걱정이다.. left join 말고 더 좋은 방법이 없을까

## 2023.01.03
오늘은 저번에 올린 코드의 리뷰를 받았다.  
초반에 단편적인 정보들만 가지고 눈에 보이는 문제부터 해결하는 식으로 코딩했었는데, 그 문제가 드러난 것 같다.  
처음에는 requestDto에서 당장 필요한 attribute를 불러왔고, entityId만으로도 연결해서 불러올 수 있다는 사실을 알고 entityId를 가져오는 형태로 바꿨었다.  
그리고 지금 전체적으로 살펴보니, 가져온 entityId를 차기이월 entityId를 통해 가져올 수 있었다. 그리고 이 Id는 차기이월 데이터를 관리하기 위해 기존에도 불러오고 있었다.  
즉, 한번에 가져오는 루트를 보지 못하고 돌아서 데이터를 가져왔다. 오늘은 이 부분을 수정했다.  
이 외에도 repository에서 left join fetch는 사용할 entity attribute가 아니면 join할 필요가 없다는 사실도 알게 되었다.  
그리고 서비스의 길이가 길어서 중복되는 부분은 최대한 따로 메소드로 빼려고 한다.  
내 코드를 전체적으로 봐주는 사람이 있다는 게 체감이 되고 든든해졌다.  
내일 다 수정해서 merge 올리자!

## 2023.01.04
엔티티의 가장 처음 row를 가져오기 위해서, 전에는 repository로 조건에 맞는 list를 order by 해서 가져오고 service 단에서 get(0)을 뽑는 방법을 사용했다.  
sql에서는 order by한 쿼리를 서브쿼리로 두고 rownum = 1을 사용하면 되지만, JPQL에서는 서브쿼리 사용이 불가능했기 때문이다.  
그런데 한 row를 가져오기 위해 수십 개의 row를 모두 가져온 뒤에 한 개만 선택하는 것은 다소 비효율적이라는 생각이 들었다.  
그래서 repository 단에서 한 row만 가져오는 방법을 찾다가 native Query라는 것을 알게 되었다.  
이름 그대로 기존에 사용하던 SQL문을 그대로 사용하는 방식이다. 다만 조건 설정, parameter 설정 들을 더 신경써야 하는 것으로 보인다.  
아직은 이해가 덜 되어서 내일 마저 더 공부하고 코드에 반영하려고 한다.  
그리고 service에서 current만을 계산하는 기능은 2번 반복해서 사용하기 때문에, 메소드로 따로 빼서 더 간결하게 만들 생각이다.  
내일은 수정해서 merge하면 시간이 다 갈 것 같다ㅎㅎ 화이팅!  
